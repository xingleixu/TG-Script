# TG-Script 基于寄存器的虚拟机设计

## 概述

TG-Script 采用基于寄存器的虚拟机架构，相比基于栈的虚拟机具有以下优势：
- 更少的指令数量（减少 push/pop 操作）
- 更好的局部性（寄存器重用）
- 更容易优化（寄存器分配优化）
- 更接近真实 CPU 架构

## 虚拟机架构

### 寄存器设计

```
虚拟机状态：
┌─────────────────────────────────────────────────────────────┐
│                    TG-Script VM                             │
├─────────────────────────────────────────────────────────────┤
│ 寄存器文件 (Register File)                                   │
│ ┌─────────┬─────────┬─────────┬─────────┬─────────┬─────────┐ │
│ │   R0    │   R1    │   R2    │   ...   │  R254   │  R255   │ │
│ └─────────┴─────────┴─────────┴─────────┴─────────┴─────────┘ │
├─────────────────────────────────────────────────────────────┤
│ 常量池 (Constants Pool)                                      │
│ ┌─────────┬─────────┬─────────┬─────────┬─────────┬─────────┐ │
│ │   K0    │   K1    │   K2    │   ...   │  K254   │  K255   │ │
│ └─────────┴─────────┴─────────┴─────────┴─────────┴─────────┘ │
├─────────────────────────────────────────────────────────────┤
│ 全局变量 (Globals)                                           │
│ ┌─────────┬─────────┬─────────┬─────────┬─────────┬─────────┐ │
│ │   G0    │   G1    │   G2    │   ...   │  G254   │  G255   │ │
│ └─────────┴─────────┴─────────┴─────────┴─────────┴─────────┘ │
├─────────────────────────────────────────────────────────────┤
│ 调用栈 (Call Stack)                                          │
│ ┌─────────────────────────────────────────────────────────┐   │
│ │ Frame N: [PC, BaseReg, LocalCount, ...]                │   │
│ │ Frame 1: [PC, BaseReg, LocalCount, ...]                │   │
│ │ Frame 0: [PC, BaseReg, LocalCount, ...]                │   │
│ └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
```

### 指令格式

采用 32 位固定长度指令，支持多种格式：

```
指令格式 A (3 操作数):
┌─────────┬─────────┬─────────┬─────────┐
│ OpCode  │    A    │    B    │    C    │
│ (8 bit) │ (8 bit) │ (8 bit) │ (8 bit) │
└─────────┴─────────┴─────────┴─────────┘

指令格式 B (2 操作数 + 16位立即数):
┌─────────┬─────────┬─────────────────────┐
│ OpCode  │    A    │        Bx           │
│ (8 bit) │ (8 bit) │      (16 bit)       │
└─────────┴─────────┴─────────────────────┘

指令格式 C (1 操作数 + 24位立即数):
┌─────────┬─────────────────────────────────┐
│ OpCode  │              Ax                 │
│ (8 bit) │           (24 bit)              │
└─────────┴─────────────────────────────────┘
```

## 指令集设计

### 基础指令

| 指令 | 格式 | 描述 | 示例 |
|------|------|------|------|
| MOVE | A | R(A) := R(B) | MOVE R1, R2 |
| LOADK | B | R(A) := K(Bx) | LOADK R1, K5 |
| LOADNIL | A | R(A) := nil | LOADNIL R1 |
| LOADBOOL | A | R(A) := bool(B) | LOADBOOL R1, true |

### 算术指令

| 指令 | 格式 | 描述 | 示例 |
|------|------|------|------|
| ADD | A | R(A) := R(B) + R(C) | ADD R1, R2, R3 |
| SUB | A | R(A) := R(B) - R(C) | SUB R1, R2, R3 |
| MUL | A | R(A) := R(B) * R(C) | MUL R1, R2, R3 |
| DIV | A | R(A) := R(B) / R(C) | DIV R1, R2, R3 |
| MOD | A | R(A) := R(B) % R(C) | MOD R1, R2, R3 |
| NEG | A | R(A) := -R(B) | NEG R1, R2 |

### 比较指令

| 指令 | 格式 | 描述 | 示例 |
|------|------|------|------|
| EQ | A | if R(B) == R(C) then PC++ | EQ R1, R2 |
| LT | A | if R(B) < R(C) then PC++ | LT R1, R2 |
| LE | A | if R(B) <= R(C) then PC++ | LE R1, R2 |

### 控制流指令

| 指令 | 格式 | 描述 | 示例 |
|------|------|------|------|
| JMP | B | PC += sBx | JMP +10 |
| TEST | A | if not R(A) then PC++ | TEST R1 |
| CALL | A | R(A)..R(A+C-1) := R(A)(R(A+1)..R(A+B-1)) | CALL R1, 2, 1 |
| RET | A | return R(A)..R(A+B-1) | RET R1, 1 |

### 对象操作指令

| 指令 | 格式 | 描述 | 示例 |
|------|------|------|------|
| NEWTABLE | A | R(A) := {} | NEWTABLE R1 |
| GETTABLE | A | R(A) := R(B)[R(C)] | GETTABLE R1, R2, R3 |
| SETTABLE | A | R(A)[R(B)] := R(C) | SETTABLE R1, R2, R3 |
| GETGLOBAL | B | R(A) := G[K(Bx)] | GETGLOBAL R1, K5 |
| SETGLOBAL | B | G[K(Bx)] := R(A) | SETGLOBAL R1, K5 |

## 寄存器分配策略

### 局部寄存器分配

```
函数调用帧布局：
┌─────────────────────────────────────────┐
│ 参数寄存器 (R0..R(argCount-1))           │
├─────────────────────────────────────────┤
│ 局部变量寄存器 (R(argCount)..R(localEnd))│
├─────────────────────────────────────────┤
│ 临时寄存器 (R(localEnd+1)..R(frameEnd)) │
└─────────────────────────────────────────┘
```

### 寄存器重用

- 编译时进行活跃性分析
- 死变量的寄存器可以被重用
- 临时表达式结果使用临时寄存器

## 性能优化特性

### 1. 指令融合

```typescript
// 原始代码
let a = b + c;
let d = a * 2;

// 优化前指令
ADD R1, R2, R3    // a = b + c
LOADK R4, K1      // load constant 2
MUL R5, R1, R4    // d = a * 2

// 优化后指令（如果 a 不再使用）
ADD R1, R2, R3    // temp = b + c
MULK R5, R1, K1   // d = temp * 2 (融合乘法和常量加载)
```

### 2. 常量折叠

```typescript
// 原始代码
let result = 3 + 4 * 5;

// 优化前
LOADK R1, K1      // load 3
LOADK R2, K2      // load 4  
LOADK R3, K3      // load 5
MUL R4, R2, R3    // 4 * 5
ADD R5, R1, R4    // 3 + (4*5)

// 优化后
LOADK R5, K4      // load 23 (预计算结果)
```

### 3. 寄存器窗口

- 函数调用时使用寄存器窗口技术
- 避免不必要的寄存器保存/恢复
- 支持尾调用优化

## 内存管理

### 垃圾回收集成

```
对象布局：
┌─────────────────────────────────────────┐
│ Header (GC标记, 类型信息, 引用计数)      │
├─────────────────────────────────────────┤
│ 对象数据                                │
└─────────────────────────────────────────┘
```

- 使用三色标记清除算法
- 写屏障支持增量GC
- 弱引用支持

### 字符串优化

- 字符串内部化（string interning）
- 小字符串优化（SSO）
- 写时复制（COW）

## 调试支持

### 调试信息

```
调试表：
┌─────────────────────────────────────────┐
│ PC -> 源码行号映射                       │
├─────────────────────────────────────────┤
│ 寄存器 -> 变量名映射                     │
├─────────────────────────────────────────┤
│ 作用域信息                              │
└─────────────────────────────────────────┘
```

### 性能分析

- 指令执行计数
- 函数调用统计
- 内存分配跟踪
- 热点代码识别

## 与现有项目的对比

### vs Tengo (基于栈)

| 特性 | Tengo | TG-Script |
|------|-------|-----------|
| 架构 | 基于栈 | 基于寄存器 |
| 指令数量 | 更多 | 更少 |
| 内存访问 | 频繁栈操作 | 直接寄存器访问 |
| 优化空间 | 有限 | 更大 |

### vs Gopher-Lua (基于寄存器)

| 特性 | Gopher-Lua | TG-Script |
|------|------------|-----------|
| 指令格式 | 32位固定 | 32位固定 |
| 寄存器数量 | 256 | 256 |
| 类型系统 | 动态 | 静态+动态 |
| 优化 | 基础 | 高级（类型推导） |

## 实现计划

1. **阶段1**: 基础指令集和虚拟机核心
2. **阶段2**: 编译器后端（AST -> 字节码）
3. **阶段3**: 运行时系统和内置函数
4. **阶段4**: 性能优化和调试支持
5. **阶段5**: 高级特性（JIT编译准备）

这个设计为未来的JIT编译器奠定了基础，寄存器架构更容易映射到真实的CPU寄存器。